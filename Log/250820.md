
###### Wed Aug 20 10:21:00 CST 2025
发现问题，make编译程序产生的`elf`、`hex`文件过大。
1. 原因：
    代码缺少`.data`端，导致调用 arm-none-eabi-objcopy 命令时，它不仅读取了位于`0x0800...`地址的程序代码，还看到了一个位于`0x2000...`地址的段（通常是.bss段）。为了生成一个连续的二进制文件，objcopy工具用0或者255（取决于命令参数）填充了384MB的空白。
   
   `Flash`(闪存) 的起始地址是：`0x08000000`，程序代码（`.text`段）被存放在这里。`SRAM` (内存) 的起始地址是：`0x20000000`全局变量、堆栈（.bss, .data, .stack段）被存放在这里。
   ```
   0x20000000 (RAM起始) - 0x08000000 (Flash起始) = 0x18000000 (十六进制)

   0x18000000 = 402,653,184 字节

   402,653,184 / 1024 = 393,216 KB
   ```
2. 解决方案：
   
   a. 在Makefile中移除`.bss`端`arm-none-eabi-objcopy -O binary -R .bss -R .stack boot.elf boot.bin`

   b. 在Makefile中只保留指定段 `arm-none-eabi-objcopy -O binary --only-section=.isr_vector --only-section=.text --only-section=.rodata --only-section=.data boot.elf boot.bin`
   c. 生成缺少端
    `.data` 段：存放已初始化且非零的可读写全局/静态变量。它的初始值存储在Flash中，但在程序启动时会被拷贝到RAM中，程序运行时可以修改RAM中的这个值。
    `.rodata` 段：存放只读数据，比如const常量和字符串字面量。它始终存储在Flash中，程序直接从Flash读取它，不会被拷贝到RAM，也不能修改。
```C
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "main.h"

// --- 段 (Section) 生成演示 ---

// 1. 生成 .rodata 段 (只读数据段)
//    - 特点: const 常量，非零初始化。
//    - 存放位置: 存储在 Flash 中，程序直接从 Flash 读取，不会拷贝到 RAM。
//    - 作用: 解决了 objcopy 的问题。
const int g_rodata_variable = 223;

// 2. 生成 .data 段 (已初始化数据段) - 这就是你想要的！
//    - 特点: 非 const 全局变量，非零初始化。
//    - 存放位置: 初始值 55 存储在 Flash 中。程序启动时，这个值会被拷贝到 RAM 中。
//                程序运行时可以修改 RAM 中的 g_data_variable。
//    - 作用: 解决了 objcopy 的问题，并且是可修改的。
int g_data_variable = 55;

// 3. 生成 .bss 段 (未初始化数据段)
//    - 特点: 未初始化或初始化为 0 的全局变量。
//    - 存放位置: 不在 Flash 中占用空间，仅在 RAM 中预留位置，并在启动时被清零。
//    - 作用: 这是导致之前 objcopy 问题的原因。
int g_bss_variable; 
// int g_another_bss_var = 0; // 这行效果和上面一样

int main(void)
{
    // 局部变量 m 存放在栈(stack)上，栈位于RAM区
    uint32_t m = 52; 
    
    // 你可以修改 .data 段的变量，因为它已经被拷贝到可读写的RAM中
    g_data_variable = g_data_variable + 1; 
    
    // 你不能修改 .rodata 段的变量 (会导致编译错误)
    // g_rodata_variable = 100; //取消这行注释会报错: "assignment of read-only variable"

    // 读取 m 的值，与 g_data_variable 的新值相加 (为了让编译器不优化掉这些变量)
    m += g_data_variable;

    while (1)
    {
        ;
    }
}

```
